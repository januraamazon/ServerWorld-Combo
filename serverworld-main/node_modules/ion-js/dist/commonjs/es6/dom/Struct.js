"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Value_1 = require("./Value");
const Ion_1 = require("../Ion");
const FromJsConstructor_1 = require("./FromJsConstructor");
class Struct extends Value_1.Value(Object, Ion_1.IonTypes.STRUCT, FromJsConstructor_1.FromJsConstructor.NONE) {
    constructor(fields, annotations = []) {
        super();
        this._fields = Object.create(null);
        for (let [fieldName, fieldValue] of fields) {
            this._fields[fieldName] = fieldValue;
        }
        this._setAnnotations(annotations);
        return new Proxy(this, {
            set: function (target, name, value) {
                target._fields[name] = value;
                return true;
            },
            get: function (target, name) {
                if (name in target) {
                    return target[name];
                }
                return target._fields[name];
            }
        });
    }
    get(...pathElements) {
        if (pathElements.length === 0) {
            throw new Error('Value#get requires at least one parameter.');
        }
        let [pathHead, ...pathTail] = pathElements;
        if (typeof (pathHead) !== "string") {
            throw new Error(`Cannot index into a struct with a ${typeof (pathHead)}.`);
        }
        let child = this._fields[pathHead];
        if (child === undefined) {
            return null;
        }
        if (pathTail.length === 0) {
            return child;
        }
        return child.get(...pathTail);
    }
    fieldNames() {
        return Object.keys(this._fields);
    }
    fields() {
        return Object.entries(this._fields);
    }
    elements() {
        return Object.values(this._fields);
    }
    [Symbol.iterator]() {
        return this.fields()[Symbol.iterator]();
    }
    toString() {
        return '{'
            + [...this.fields()]
                .map(([name, value]) => name + ': ' + value)
                .join(', ')
            + '}';
    }
    writeTo(writer) {
        writer.setAnnotations(this.getAnnotations());
        writer.stepIn(Ion_1.IonTypes.STRUCT);
        for (let [fieldName, value] of this) {
            writer.writeFieldName(fieldName);
            value.writeTo(writer);
        }
        writer.stepOut();
    }
    toJSON() {
        return this._fields;
    }
    static _fromJsValue(jsValue, annotations) {
        if (!(jsValue instanceof Object)) {
            throw new Error(`Cannot create a dom.Struct from: ${jsValue.toString()}`);
        }
        let fields = Object.entries(jsValue)
            .map(([key, value]) => [key, Value_1.Value.from(value)]);
        return new this(fields, annotations);
    }
}
exports.Struct = Struct;
//# sourceMappingURL=Struct.js.map