"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ion = __importStar(require("../Ion"));
const Ion_1 = require("../Ion");
const Struct_1 = require("./Struct");
const List_1 = require("./List");
const SExpression_1 = require("./SExpression");
const Null_1 = require("./Null");
const Integer_1 = require("./Integer");
const Float_1 = require("./Float");
const Decimal_1 = require("./Decimal");
const Timestamp_1 = require("./Timestamp");
const Symbol_1 = require("./Symbol");
const Clob_1 = require("./Clob");
const Blob_1 = require("./Blob");
const IonTextReader_1 = require("../IonTextReader");
const IonBinaryReader_1 = require("../IonBinaryReader");
function loadAll(ionData) {
    let reader = _createReader(ionData);
    let ionValues = [];
    while (reader.next()) {
        ionValues.push(_loadValue(reader));
    }
    return ionValues;
}
exports.loadAll = loadAll;
function load(ionData) {
    let reader = _createReader(ionData);
    if (reader.type() === null) {
        reader.next();
    }
    return reader.type() === null ? null : _loadValue(reader);
}
exports.load = load;
function _createReader(ionData) {
    if (ionData instanceof IonTextReader_1.TextReader || ionData instanceof IonBinaryReader_1.BinaryReader) {
        return ionData;
    }
    return Ion_1.makeReader(ionData);
}
function _loadValue(reader) {
    let ionType = reader.type();
    if (ionType === null) {
        throw new Error("loadValue() called when no further values were available to read.");
    }
    let annotations = reader.annotations();
    if (reader.isNull()) {
        return new Null_1.Null(reader.type(), annotations);
    }
    switch (ionType) {
        case Ion_1.IonTypes.NULL: return new Null_1.Null(Ion_1.IonTypes.NULL, annotations);
        case Ion_1.IonTypes.BOOL: return new ion.dom.Boolean(reader.booleanValue(), annotations);
        case Ion_1.IonTypes.INT:
            return reader.intSize() == Ion_1.IntSize.Number
                ? new Integer_1.Integer(reader.numberValue(), annotations)
                : new Integer_1.Integer(reader.bigIntValue(), annotations);
        case Ion_1.IonTypes.FLOAT: return new Float_1.Float(reader.numberValue(), annotations);
        case Ion_1.IonTypes.DECIMAL: return new Decimal_1.Decimal(reader.decimalValue(), annotations);
        case Ion_1.IonTypes.TIMESTAMP: return new Timestamp_1.Timestamp(reader.timestampValue(), annotations);
        case Ion_1.IonTypes.SYMBOL: return new Symbol_1.Symbol(reader.stringValue(), annotations);
        case Ion_1.IonTypes.STRING: return new ion.dom.String(reader.stringValue(), annotations);
        case Ion_1.IonTypes.CLOB: return new Clob_1.Clob(reader.byteValue(), annotations);
        case Ion_1.IonTypes.BLOB: return new Blob_1.Blob(reader.byteValue(), annotations);
        case Ion_1.IonTypes.LIST: return _loadList(reader);
        case Ion_1.IonTypes.SEXP: return _loadSExpression(reader);
        case Ion_1.IonTypes.STRUCT: return _loadStruct(reader);
        default: throw new Error(`Unrecognized IonType '${ionType}' found.`);
    }
}
function _loadStruct(reader) {
    let children = new Map();
    let annotations = reader.annotations();
    reader.stepIn();
    while (reader.next()) {
        children.set(reader.fieldName(), _loadValue(reader));
    }
    reader.stepOut();
    return new Struct_1.Struct(children.entries(), annotations);
}
function _loadList(reader) {
    let annotations = reader.annotations();
    return new List_1.List(_loadSequence(reader), annotations);
}
function _loadSExpression(reader) {
    let annotations = reader.annotations();
    return new SExpression_1.SExpression(_loadSequence(reader), annotations);
}
function _loadSequence(reader) {
    let children = [];
    reader.stepIn();
    while (reader.next()) {
        children.push(_loadValue(reader));
    }
    reader.stepOut();
    return children;
}
var Value_1 = require("./Value");
exports.Value = Value_1.Value;
var Null_2 = require("./Null");
exports.Null = Null_2.Null;
var Boolean_1 = require("./Boolean");
exports.Boolean = Boolean_1.Boolean;
var Integer_2 = require("./Integer");
exports.Integer = Integer_2.Integer;
var Float_2 = require("./Float");
exports.Float = Float_2.Float;
var Decimal_2 = require("./Decimal");
exports.Decimal = Decimal_2.Decimal;
var Timestamp_2 = require("./Timestamp");
exports.Timestamp = Timestamp_2.Timestamp;
var String_1 = require("./String");
exports.String = String_1.String;
var Symbol_2 = require("./Symbol");
exports.Symbol = Symbol_2.Symbol;
var Blob_2 = require("./Blob");
exports.Blob = Blob_2.Blob;
var Clob_2 = require("./Clob");
exports.Clob = Clob_2.Clob;
var Struct_2 = require("./Struct");
exports.Struct = Struct_2.Struct;
var List_2 = require("./List");
exports.List = List_2.List;
var SExpression_2 = require("./SExpression");
exports.SExpression = SExpression_2.SExpression;
//# sourceMappingURL=index.js.map