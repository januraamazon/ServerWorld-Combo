var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
define(["require", "exports", "../Ion", "../Ion", "./Struct", "./List", "./SExpression", "./Null", "./Integer", "./Float", "./Decimal", "./Timestamp", "./Symbol", "./Clob", "./Blob", "../IonTextReader", "../IonBinaryReader", "./Value", "./Null", "./Boolean", "./Integer", "./Float", "./Decimal", "./Timestamp", "./String", "./Symbol", "./Blob", "./Clob", "./Struct", "./List", "./SExpression"], function (require, exports, ion, Ion_1, Struct_1, List_1, SExpression_1, Null_1, Integer_1, Float_1, Decimal_1, Timestamp_1, Symbol_1, Clob_1, Blob_1, IonTextReader_1, IonBinaryReader_1, Value_1, Null_2, Boolean_1, Integer_2, Float_2, Decimal_2, Timestamp_2, String_1, Symbol_2, Blob_2, Clob_2, Struct_2, List_2, SExpression_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ion = __importStar(ion);
    function loadAll(ionData) {
        let reader = _createReader(ionData);
        let ionValues = [];
        while (reader.next()) {
            ionValues.push(_loadValue(reader));
        }
        return ionValues;
    }
    exports.loadAll = loadAll;
    function load(ionData) {
        let reader = _createReader(ionData);
        if (reader.type() === null) {
            reader.next();
        }
        return reader.type() === null ? null : _loadValue(reader);
    }
    exports.load = load;
    function _createReader(ionData) {
        if (ionData instanceof IonTextReader_1.TextReader || ionData instanceof IonBinaryReader_1.BinaryReader) {
            return ionData;
        }
        return Ion_1.makeReader(ionData);
    }
    function _loadValue(reader) {
        let ionType = reader.type();
        if (ionType === null) {
            throw new Error("loadValue() called when no further values were available to read.");
        }
        let annotations = reader.annotations();
        if (reader.isNull()) {
            return new Null_1.Null(reader.type(), annotations);
        }
        switch (ionType) {
            case Ion_1.IonTypes.NULL: return new Null_1.Null(Ion_1.IonTypes.NULL, annotations);
            case Ion_1.IonTypes.BOOL: return new ion.dom.Boolean(reader.booleanValue(), annotations);
            case Ion_1.IonTypes.INT:
                return reader.intSize() == Ion_1.IntSize.Number
                    ? new Integer_1.Integer(reader.numberValue(), annotations)
                    : new Integer_1.Integer(reader.bigIntValue(), annotations);
            case Ion_1.IonTypes.FLOAT: return new Float_1.Float(reader.numberValue(), annotations);
            case Ion_1.IonTypes.DECIMAL: return new Decimal_1.Decimal(reader.decimalValue(), annotations);
            case Ion_1.IonTypes.TIMESTAMP: return new Timestamp_1.Timestamp(reader.timestampValue(), annotations);
            case Ion_1.IonTypes.SYMBOL: return new Symbol_1.Symbol(reader.stringValue(), annotations);
            case Ion_1.IonTypes.STRING: return new ion.dom.String(reader.stringValue(), annotations);
            case Ion_1.IonTypes.CLOB: return new Clob_1.Clob(reader.byteValue(), annotations);
            case Ion_1.IonTypes.BLOB: return new Blob_1.Blob(reader.byteValue(), annotations);
            case Ion_1.IonTypes.LIST: return _loadList(reader);
            case Ion_1.IonTypes.SEXP: return _loadSExpression(reader);
            case Ion_1.IonTypes.STRUCT: return _loadStruct(reader);
            default: throw new Error(`Unrecognized IonType '${ionType}' found.`);
        }
    }
    function _loadStruct(reader) {
        let children = new Map();
        let annotations = reader.annotations();
        reader.stepIn();
        while (reader.next()) {
            children.set(reader.fieldName(), _loadValue(reader));
        }
        reader.stepOut();
        return new Struct_1.Struct(children.entries(), annotations);
    }
    function _loadList(reader) {
        let annotations = reader.annotations();
        return new List_1.List(_loadSequence(reader), annotations);
    }
    function _loadSExpression(reader) {
        let annotations = reader.annotations();
        return new SExpression_1.SExpression(_loadSequence(reader), annotations);
    }
    function _loadSequence(reader) {
        let children = [];
        reader.stepIn();
        while (reader.next()) {
            children.push(_loadValue(reader));
        }
        reader.stepOut();
        return children;
    }
    exports.Value = Value_1.Value;
    exports.Null = Null_2.Null;
    exports.Boolean = Boolean_1.Boolean;
    exports.Integer = Integer_2.Integer;
    exports.Float = Float_2.Float;
    exports.Decimal = Decimal_2.Decimal;
    exports.Timestamp = Timestamp_2.Timestamp;
    exports.String = String_1.String;
    exports.Symbol = Symbol_2.Symbol;
    exports.Blob = Blob_2.Blob;
    exports.Clob = Clob_2.Clob;
    exports.Struct = Struct_2.Struct;
    exports.List = List_2.List;
    exports.SExpression = SExpression_2.SExpression;
});
//# sourceMappingURL=index.js.map